<sub>v0.1</sub>

# one_at_a_time

Pitfall: the temptation to kill two birds with one stone.

Minimize the chance of multiple things going wrong at the same time.

# Simplify and prototype (iterative)

e.g. "How do I implement a binary search on a sorted list of 1,000 integers in Python, with logging for every step of the search process?"

e.g. Write test code for Telegram notification upon transactions

# Walkthrough specific examples

e.g. Hand write inputs and outputs of test cases for the CP Ad Manager ledger & transactions

e.g. Solving general recursive math function in mid school. (f[1] = 10; f[n] = 1/2 * f[n-1]. Sum(f) = ?)

# Generalize

Generalize from a specific use case to generate the search keyword

e.g. "How do I format a table with 5 rows and 3 columns in a CSV file using Python?"

(Paradigm shifted with LLM)

# Logic error vs syntax error

e.g. `if (a = 1)`

# Leverage debugger

To verify if the intermediary execution result match your logic

# Fake it before make it

e.g. Stub/Mock. So that you can move on to next part first

# start with working state (esp. when troubleshooting)

e.g. start with example code / start with good commit

"All happy families are alike; each unhappy family is unhappy in its own way."

# When and how to borrow code?

Google. ChatGPT. Package.

Make sure you understand the code. vs Make sure you understand how to use the code.

# don't be afriad to break things

test often, break fast

Build a comfortable dev environment

# temporary solution vs best practice

"Perfection is not attainable, but if we chase perfection, we can catch excellence." - Vince Lombardi

[< Previous Chapter](3_identify_problem.md) | [Next Chapter >](5_decompose.md)
